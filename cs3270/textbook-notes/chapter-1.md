# Chapter 1 - Preliminaries

## 1.1 Reasons for studying concepts of PLs
- Increased capacity to express ideas
- Improved background for choosing appropriate lang
- Increased ability to learn new langs
- Better understanding of the significance of implementation (more to do with compiler design)
- Better use of known langs
- Overall advancement of computing

## 1.2 Programming Domains
- Scientific
    - FORTRAN
- Business
    - COBOL
- AI
    - Lisp, prolog, scheme
- Web
    - HTML, markup, JS & PHP
- Teaching
    - Pascal

## 1.3 Language Evaluation Criteria
- Readability
    - Simplicity
    - Orthogonality
        - Relatively small set of primitive constructs combined in small number of ways
    - Data Types
    - Syntax design
- Writability
    - Simplicity and Orthogonality
    - Expressivity
- Reliability
    - Type checking
    - Exception Handling
    - Aliasing
    - Readability & writability
- Cost
    - Training to use
    - Actually writing (writability)
    - Compilation
    - Execution
    - System implementation
    - Poor readability
    - Maintenance

## 1.4 Influences on Language Design
- Computer Architecture
    - von Neumann (fetch/decode/execute)
        - imperative languages (program & data in same memory)
        - won't be displaced until efficient non-von Neumann system developed for efficient execution of functional languages
- Programming Design Methodologies
    - OOP / Inheritance
    - Procedure-oriented

## 1.5 Language Categories
- Imperative
- Functional
- Logic
- OO

## 1.6 Language Design Trade-offs
- Reliability / cost of execution

## 1.7 Implementation Methods
- Compilation
- Pure interpretation
- Hybrid
- Preprocessors

## 1.8 Programming Environments
- OS / Editing environment 
